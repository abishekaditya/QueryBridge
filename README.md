# GraphQL‑to‑Datalog Optimizer (Lean 4 Edition)

> **Course project design document**

*Translate GraphQL queries into provably optimal Datalog programs, using Lean 4 for compilation/analysis and XSB for execution.*

---

## Part I. Problem & Plan

### 1 Problem description [Link to Old Gist](https://gist.github.com/abishekaditya/837bbc7261a7bc28df3bac692535d710)

| Aspect                | Specification                                                                                                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Input**             | • GraphQL schema `schema.graphql` and query file `query.graphql`.• Optional JSON variables file.• Edge‑labeled data source — SQLite/Postgres or CSV — converted to facts.                                                                                     |
| **Output**            | • An **optimised Datalog program** (`out.P`) generated by Lean.• Complexity certificate (e.g. `O(E)`, `O(V + E)`).• Query result tuples emitted by XSB as JSON/CSV.                                                                                           |
| **Requirements**      | Pure Lean 4 implementation of compiler/optimizer; may shell‑out only to **XSB 4.0+** for bottom‑up evaluation. Target asymptotic complexity no worse than existing magic‑set approaches; empirical speed within 2× XSB hand‑written rules on benchmark suite. |
| **Example use‑cases** | *Static code analysis* (call‑graph reachability), *social‑network queries* (friends‑of‑friends with filters), *supply‑chain provenance*, *knowledge‑graph traversal*.                                                                                         |

### 2 State of the art

| System                                  | Approach                                                      | Pros                              | Cons                                                                |
| --------------------------------------- | ------------------------------------------------------------- | --------------------------------- | ------------------------------------------------------------------- |
| **Apollo/Facebook resolvers**           | Imperative field‑by‑field SQL/REST fetching                   | Mature ecosystem                  | No global optimisation; N+1 queries                                 |
| **ImplGraphQL** (Liu 2010)              | Rules‑based translation to Datalog with demand transformation | Gives complexity guarantees       | Prototype only, no implementation                                   |
| **Soufflé**                             | Bottom‑up semi‑naïve Datalog                                  | Fast on dense relations           | Lacks demand‑driven filtering; slower than XSB on recursive queries |
| **clingo**                              | ASP (stable‑model) solving                                    | Rich modelling                    | Orders of magnitude slower on classical Datalog benchmarks          |
| **XSB**                                 | Tabling, subsumptive demand transformation                    | Very fast; guarantees termination | Needs hand‑written rules; no GraphQL front‑end                      |
| **Lean graph‑library** (Kementzey 2021) | Pure Lean graphs + algorithms                                 | Reusable, performant              | Not yet integrated with GraphQL tooling                             |

No existing tool provides **automatic best‑complexity translation from GraphQL to Datalog** within Lean 4.

### 3 Tasks & subtasks

1. **Grammar & parser** (GQL → AST)
2. **AST → Datalog IR translator**
3. **Recursion conversion** meta‑pass
4. **Hypothesis permutation (SIPS)** search
5. **Demand transformation** (subsumptive)
6. **Specialisation & codegen** to XSB
7. **Lean graph‑library integration** for analysis utilities
8. **CLI driver & test harness**
9. **Benchmark & evaluation scripts**
10. **Documentation & report**


## Part II. Design

Currently, the Basic.lean file is just a AI generated code that is there to pass the basic test case. Actual development is happening in parallel, which, when done will replace Basic.lean.

## Installation

1. Clone the repository:
```bash
git clone https://github.com/abishekaditya/QueryBridge.git
cd QueryBridge
```

2. Build the project using Lake:
```bash
lake build
```

## Usage

```bash
# Run with default test files
.lake/build/bin/querybridge

# Run with custom files
.lake/build/bin/querybridge path/to/schema.graphql path/to/query.graphql path/to/output.xsb
```

## Example

With a GraphQL schema:

```graphql
type User {
  username: String!
}

type Project {
  name: String!
  tagline: String
  contributors: [User!]!
}

type Query {
  # Fetch a single project by name.
  project(name: String!): Project
}
```

And a query:

```graphql
{
  project(name: "GraphQL") {
    tagline
  }
}
```

The tool will generate the following XSB Datalog code:

```prolog
ans(Tagline) :- project("GraphQL", Tagline).
```

## Project Structure

```
.
├── Main.lean              # CLI application
├── docs/                  # Documentation files
├── scripts/               # Utility scripts
├── src/                   # Source code
│   ├── QueryBridge.lean   # Main library module
│   └── QueryBridge/       # Library components
│       └── Basic.lean     # Core translator functionality
├── test/                  # Test cases
│   ├── basic/             # Basic test examples
│   │   ├── facts.xsb      # Example Datalog facts
│   │   ├── query.graphql  # Example GraphQL query
│   │   ├── result.xsb     # Expected output
│   │   └── schema.graphql # Example GraphQL schema
│   ├── nested_tables/     # Complex nested relationships test
│   ├── bad_normalization/ # Denormalized schema test
│   └── window_functions/  # SQL window function-like analytics test
├── run-tests.sh           # Test runner script
├── lakefile.toml          # Lake build configuration
├── doc-gen.toml           # Documentation generation config
└── README.md              # This file
```

## Testing

To ensure the translator is working correctly:

1. Build the project:
```bash
lake build
```

2. Run the translator with the basic test case:
```bash
.lake/build/bin/querybridge
```

3. Verify the output matches the expected result:
```bash
# Expected output
ans(Tagline) :- project("GraphQL", Tagline).
```

### Running All Tests (Does not work Right Now)

The project includes multiple test cases that exercise different aspects of the GraphQL to Datalog translation:

- **Basic**: Simple GraphQL query with a single field
- **Nested Tables**: Tests deep nesting of entities with multiple levels of relationships
- **Bad Normalization**: Tests handling of denormalized schemas with redundant data
- **Window Functions**: Tests analytical functions similar to SQL window functions

To run all tests sequentially:

```bash
./run-tests.sh
```

### Running Individual Tests

You can run tests individually using:

```bash
# Run the basic test case
.lake/build/bin/querybridge test/basic/schema.graphql test/basic/query.graphql test/basic/output.xsb

# Run the nested tables test case
.lake/build/bin/querybridge test/nested_tables/schema.graphql test/nested_tables/query.graphql test/nested_tables/output.xsb

# Run the bad normalization test case
.lake/build/bin/querybridge test/bad_normalization/schema.graphql test/bad_normalization/query.graphql test/bad_normalization/output.xsb

# Run the window functions test case
.lake/build/bin/querybridge test/window_functions/schema.graphql test/window_functions/query.graphql test/window_functions/output.xsb
```

### Creating Your Own Test Cases

You can create your own test cases by:
1. Creating a directory under `test/` with a descriptive name
2. Adding a GraphQL schema file (`schema.graphql`)
3. Adding a GraphQL query file (`query.graphql`)
4. Adding a file with sample data (`facts.xsb`)
5. Adding a file with expected output (`result.xsb`)
6. Running the translator with these files
7. Verifying the XSB Datalog output

## Documentation

The project uses the official Lean 4 documentation tool `doc-gen4` to generate comprehensive documentation.

### Generating Documentation

To generate the documentation:

1. Run the documentation generation script:
```bash
./scripts/gen-docs.sh
```

2. The script will:
   - Ensure DocGen4 is installed as a dependency
   - Build the project and the DocGen4 tool
   - Generate HTML documentation in the `docs/` directory

3. View the documentation in your browser:
```bash
open docs/index.html
```

The documentation is generated from the doc comments in the source code, following the Lean 4 documentation standards.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments


## Part V. References & Credits

1. Y. Liu & S. Stoller, *From Datalog Rules to Efficient Programs with Precise Complexity Analysis*, PPoPP 2009
2. T. Tekle & Y. Liu, *Subsumptive Demand Transformation for Datalog*, PPDP 2010
3. GraphQL Working Group, *GraphQL Specification*, Oct 2021, [https://spec.graphql.org/October2021/](https://spec.graphql.org/October2021/)
4. P. Kementzey, *A Graph Library for Lean 4*, BSc thesis, VU Amsterdam, 2021, [https://lean-forward.github.io/pubs/kementzey\_bsc\_thesis.pdf](https://lean-forward.github.io/pubs/kementzey_bsc_thesis.pdf)
5. L. de Moura *et al.*, *The Lean 4 Theorem Prover*, POPL 2021
6. XSB Systems Group, *XSB 4.0 Manual*, 2024.
7. Soufflé Development Team, *Soufflé Datalog Engine*, [https://souffle-lang.github.io](https://souffle-lang.github.io)
8. G. Gebser *et al.*, *clingo User Guide*, 2024.
  

**Acknowledgements** —

Prof. Yanhong Liu for project guidance;

Claude AI for helping generate code to make basic test case pass. Will be replaced with proper working code in the future;

