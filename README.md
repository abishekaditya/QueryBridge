# GraphQL‑to‑Datalog Optimizer (Lean 4 Edition)

> **Course project design document**

*Translate GraphQL queries into provably optimal Datalog programs, using Lean 4 for compilation/analysis and XSB for execution.*

---

## Part I. Problem & Plan

### 1 Problem description [Link to Old Gist](https://gist.github.com/abishekaditya/837bbc7261a7bc28df3bac692535d710)

| Aspect                | Specification                                                                                                                                                                                                                                                 |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Input**             | • GraphQL schema `schema.graphql` and query file `query.graphql`.• Optional JSON variables file.• Edge‑labeled data source — SQLite/Postgres or CSV — converted to facts.                                                                                     |
| **Output**            | • An **optimised Datalog program** (`out.P`) generated by Lean.• Complexity certificate (e.g. `O(E)`, `O(V + E)`).• Query result tuples emitted by XSB as JSON/CSV.                                                                                           |
| **Requirements**      | Pure Lean 4 implementation of compiler/optimizer; may shell‑out only to **XSB 4.0+** for bottom‑up evaluation. Target asymptotic complexity no worse than existing magic‑set approaches; empirical speed within 2× XSB hand‑written rules on benchmark suite. |
| **Example use‑cases** | *Static code analysis* (call‑graph reachability), *social‑network queries* (friends‑of‑friends with filters), *supply‑chain provenance*, *knowledge‑graph traversal*.                                                                                         |

### 2 State of the art

| System                                  | Approach                                                      | Pros                              | Cons                                                                |
| --------------------------------------- | ------------------------------------------------------------- | --------------------------------- | ------------------------------------------------------------------- |
| **Apollo/Facebook resolvers**           | Imperative field‑by‑field SQL/REST fetching                   | Mature ecosystem                  | No global optimisation; N+1 queries                                 |
| **ImplGraphQL** (Liu 2010)              | Rules‑based translation to Datalog with demand transformation | Gives complexity guarantees       | Prototype only, no implementation                                   |
| **Soufflé**                             | Bottom‑up semi‑naïve Datalog                                  | Fast on dense relations           | Lacks demand‑driven filtering; slower than XSB on recursive queries |
| **clingo**                              | ASP (stable‑model) solving                                    | Rich modelling                    | Orders of magnitude slower on classical Datalog benchmarks          |
| **XSB**                                 | Tabling, subsumptive demand transformation                    | Very fast; guarantees termination | Needs hand‑written rules; no GraphQL front‑end                      |
| **Lean graph‑library** (Kementzey 2021) | Pure Lean graphs + algorithms                                 | Reusable, performant              | Not yet integrated with GraphQL tooling                             |

No existing tool provides **automatic best‑complexity translation from GraphQL to Datalog** within Lean 4.

### 3 Tasks & subtasks

1. **Grammar & parser** (GQL → AST)
2. **AST → Datalog IR translator**
3. **Recursion conversion** meta‑pass
4. **Hypothesis permutation (SIPS)** search
5. **Demand transformation** (subsumptive)
6. **Specialisation & codegen** to XSB
7. **Lean graph‑library integration** for analysis utilities
8. **CLI driver & test harness**
9. **Benchmark & evaluation scripts**
10. **Documentation & report**


## Part II. Design

Currently, the Basic.lean file is just a AI generated code that is there to pass the basic test case. Actual development is happening in parallel, which, when done will replace Basic.lean.

## Installation

1. Clone the repository:
```bash
git clone https://github.com/abishekaditya/QueryBridge.git
cd QueryBridge
```

2. Build the project using Lake:
```bash
lake build
```

## Usage

```bash
# Run with default test files
.lake/build/bin/querybridge

# Run with custom files
.lake/build/bin/querybridge path/to/schema.graphql path/to/query.graphql path/to/output.xsb
```

## Example

With a GraphQL schema:

```graphql
type User {
  username: String!
}

type Project {
  name: String!
  tagline: String
  contributors: [User!]!
}

type Query {
  # Fetch a single project by name.
  project(name: String!): Project
}
```

And a query:

```graphql
{
  project(name: "GraphQL") {
    tagline
  }
}
```

The tool will generate the following XSB Datalog code:

```prolog
ans(Tagline) :- project("GraphQL", Tagline).
```

## Project Structure

```
.
├── Main.lean              # CLI application
├── docs/                  # Documentation files
├── scripts/               # Utility scripts
├── src/                   # Source code
│   ├── QueryBridge.lean   # Main library module
│   └── QueryBridge/       # Library components
│       └── Basic.lean     # Core translator functionality
├── test/                  # Test cases
│   ├── basic/             # Basic test examples
│   │   ├── facts.xsb      # Example Datalog facts
│   │   ├── query.graphql  # Example GraphQL query
│   │   ├── result.xsb     # Expected output
│   │   └── schema.graphql # Example GraphQL schema
│   ├── nested_tables/     # Complex nested relationships test
│   ├── bad_normalization/ # Denormalized schema test
│   └── window_functions/  # SQL window function-like analytics test
├── run-tests.sh           # Test runner script
├── lakefile.toml          # Lake build configuration
├── doc-gen.toml           # Documentation generation config
└── README.md              # This file
```

## Testing

To ensure the translator is working correctly:

1. Build the project:
```bash
lake build
```

2. Run the translator with the basic test case:
```bash
./build/bin/querybridge
```

3. Verify the output matches the expected result:
```bash
# Expected output
ans(Tagline) :- project("GraphQL", Tagline).
```

### Running All Tests

The project includes multiple test cases that exercise different aspects of the GraphQL to Datalog translation:

- **Basic**: Simple GraphQL query with a single field
- **Nested Tables**: Tests deep nesting of entities with multiple levels of relationships
- **Bad Normalization**: Tests handling of denormalized schemas with redundant data
- **Window Functions**: Tests analytical functions similar to SQL window functions

To run all tests sequentially:

```bash
./run-tests.sh
```

### Running Individual Tests

Tests can be run individually using:

```bash
# Run the basic test case
./build/bin/querybridge test/basic/schema.graphql test/basic/query.graphql test/basic/output.xsb

# Run the nested tables test case
./build/bin/querybridge test/nested_tables/schema.graphql test/nested_tables/query.graphql test/nested_tables/output.xsb

# Run the bad normalization test case
./build/bin/querybridge test/bad_normalization/schema.graphql test/bad_normalization/query.graphql test/bad_normalization/output.xsb

# Run the window functions test case
./build/bin/querybridge test/window_functions/schema.graphql test/window_functions/query.graphql test/window_functions/output.xsb
```

### Creating Your Own Test Cases

New test cases can be added by:
1. Creating a directory under `test/` with a descriptive name
2. Adding a GraphQL schema file (`schema.graphql`)
3. Adding a GraphQL query file (`query.graphql`)
4. Adding a file with sample data (`facts.xsb`)
5. Adding a file with expected output (`result.xsb`)
6. Running the translator with these files
7. Verifying the XSB Datalog output

## Documentation

The project uses the official Lean 4 documentation tool `doc-gen4` to generate comprehensive documentation.

### Generating Documentation

To generate the documentation:

1. Run the documentation generation script:
```bash
./scripts/gen-docs.sh
```

2. The script will:
   - Ensure DocGen4 is installed as a dependency
   - Build the project and the DocGen4 tool
   - Generate Markdown documentation in the `docs/` directory

The documentation is generated from the doc comments in the source code, following the Lean 4 documentation standards.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Part V. References & Credits

1. Liu, Y., & Stoller, S. D. (2009). "From Datalog Rules to Efficient Programs with Precise Complexity Analysis". In *Proceedings of the 14th ACM SIGPLAN Symposium on Principles and Practice of Parallel Programming* (PPoPP '09), pp. 109-120. ACM, New York, NY, USA. DOI: 10.1145/1504176.1504191

2. Tekle, T., & Liu, Y. (2010). "Subsumptive Demand Transformation for Datalog". In *Proceedings of the 12th International ACM SIGPLAN Symposium on Principles and Practice of Declarative Programming* (PPDP '10), pp. 75-84. ACM, New York, NY, USA. DOI: 10.1145/1836089.1836099

3. GraphQL Working Group (2021). "GraphQL Specification" (October 2021 Edition). Retrieved from: [https://spec.graphql.org/October2021/](https://spec.graphql.org/October2021/) (Accessed: March 18, 2025)

4. Kementzey, P. (2021). "A Graph Library for Lean 4". BSc thesis, Vrije Universiteit Amsterdam. Retrieved from: [https://lean-forward.github.io/pubs/kementzey_bsc_thesis.pdf](https://lean-forward.github.io/pubs/kementzey_bsc_thesis.pdf) (Accessed: March 19, 2025)

5. de Moura, L., Ullrich, S., Avigad, J., Kong, S., Roesch, J., & van Doorn, F. (2021). "The Lean 4 Theorem Prover and Programming Language". In *Proceedings of the 10th ACM SIGPLAN International Conference on Certified Programs and Proofs* (CPP 2021), pp. 378-394. ACM, New York, NY, USA. DOI: 10.1145/3437992.3439931

6. XSB Research Group (2024). "The XSB System Version 4.0: Programmer's Manual". Department of Computer Science, Stony Brook University. Retrieved from: [http://xsb.sourceforge.net/manual/manual1.pdf](http://xsb.sourceforge.net/manual/manual1.pdf) (Accessed: March 19, 2025)

7. Scholz, B., Jordan, H., Subotić, P., & Westmann, T. (2016). "Soufflé: On Synthesis of Program Analyzers". In *Computer Aided Verification* (CAV 2016), pp. 422-430. Springer, Cham. DOI: 10.1007/978-3-319-41540-6_23. Software available at: [https://souffle-lang.github.io](https://souffle-lang.github.io) (Accessed: Match 18, 2025)


**Acknowledgements**

- Prof. Yanhong Annie Liu (Stony Brook University) for project guidance
- Anthropic (2023-2024). "Claude AI". Used for generating initial code in Basic.lean to pass the basic test case. Will be replaced with proper working code in the future.
